Require Import String.
Require Import Arith.

Inductive Signal : Set :=
  | And2  : Signal -> Signal -> Signal
  | Or2   : Signal -> Signal -> Signal
  | Xor2  : Signal -> Signal -> Signal
  | Eq2   : Signal -> Signal -> Signal
  | Nand2 : Signal -> Signal -> Signal
  | Nor2  : Signal -> Signal -> Signal
  | Not1  : Signal -> Signal
  | Bit1  : Signal
  | Bit0  : Signal
  | Bitv  : string -> Signal
  | Letb  : string -> Signal -> Signal -> Signal
with Signal_Pair : Set :=
  | Spair : Signal -> Signal -> Signal_Pair
  | Letb2 : string -> Signal -> Signal_Pair -> Signal_Pair
.

Definition Signal2 := (Signal * Signal)%type.

Fixpoint subst (s:Signal) (v:string) (e:Signal) : Signal :=
  let st s := subst s v e in
  match s with
   | Bit0 => Bit0
   | Bit1 => Bit1
   | Not1 r => Not1 (st r)
   | And2  r1 r2 => And2  (st r1) (st r2)
   | Or2   r1 r2 => Or2   (st r1) (st r2)
   | Xor2  r1 r2 => Xor2  (st r1) (st r2)
   | Eq2   r1 r2 => Eq2   (st r1) (st r2)
   | Nand2 r1 r2 => Nand2 (st r1) (st r2)
   | Nor2  r1 r2 => Nor2  (st r1) (st r2)
   | Letb v e1 e2 => subst e1 v e2
   | Bitv v' => if eqb v v' then e else s
  end.

Definition subst2 (sc : Signal2) (v:string) (e:Signal) : Signal2 :=
  let (sum,cout) := sc in
    (subst sum v e, subst cout v e).
 
Fixpoint eval_signal (s:Signal) (v:string) (e:Signal) : Signal :=
  let st s := eval_signal s v e in
  match s with
   | Bit0 => Bit0
   | Bit1 => Bit1
   | Not1 r => Not1 (st r)
   | And2  r1 r2 => And2  (st r1) (st r2)
   | Or2   r1 r2 => Or2   (st r1) (st r2)
   | Xor2  r1 r2 => Xor2  (st r1) (st r2)
   | Eq2   r1 r2 => Eq2   (st r1) (st r2)
   | Nand2 r1 r2 => Nand2 (st r1) (st r2)
   | Nor2  r1 r2 => Nor2  (st r1) (st r2)
   | Letb v e1 e2 => subst e1 v e2
   | Bitv v' => if eqb v v' then e else s
  end.

Definition eval_signal2 (sc:Signal2) (v:string) (e:Signal) : Signal2 :=
  let (sum,cout) := sc in
    (eval_signal sum v e, eval_signal cout v e).
  
Definition nandb a b := negb (andb a b).
Definition norb a b := negb (orb a b).

Definition bool_to_nat (b : bool) :=
  match b with
  | true => 1
  | false => 0
  end.

Coercion bool_to_nat : bool >-> nat.

Fixpoint signal2bool (s:Signal) (env : string -> bool) {struct s} : bool :=
 let s2b s := signal2bool s env in
 match s with
   | Bit0 => false
   | Bit1 => true
   | Not1 r => negb (s2b r)
   | And2  r1 r2 => andb  (s2b r1) (s2b r2)
   | Or2   r1 r2 => orb   (s2b r1) (s2b r2)
   | Xor2  r1 r2 => xorb  (s2b r1) (s2b r2)
   | Eq2   r1 r2 => negb (xorb  (s2b r1) (s2b r2))
   | Nand2 r1 r2 => nandb (s2b r1) (s2b r2)
   | Nor2  r1 r2 => negb (orb (s2b r1) (s2b r2))
   | Bitv v => env v
   | Letb v e1 e2 => 
       let v1 := s2b e1 in
       let env1 x := if eqb x v then v1 else env x in
          signal2bool e2 env1
 end.

Definition signal2_to_bool (sc:Signal2) (env:string->bool) : bool*bool :=
  let (sum,cout) := sc in
    (signal2bool sum env, signal2bool cout env).


Definition s2b s := signal2bool s (fun x => true).

Definition b2s (b:bool) : Signal :=
  match b with
   | true  => Bit1
   | false => Bit0
  end.

(* convert boolean to diginal string "0" or "1". *)
Definition b2d (b:bool) : string :=
  match b with
   | true  => "1"
   | false => "0"
  end.

Definition full_adder_s_tp := Signal -> Signal -> Signal -> Signal2.

Declare Scope Signal_scope.
Open Scope Signal_scope.
Infix "||"  := Or2   (at level 50, left associativity)  : Signal_scope.
Infix "&&"  := And2  (at level 40, left associativity)  : Signal_scope.
Infix "!&"  := Nand2 (at level 40, left associativity)  : Signal_scope.
Infix "=="  := Eq2   (at level 38, left associativity)  : Signal_scope.
Infix "(+)" := Xor2  (at level 38, left associativity)  : Signal_scope.
Infix "(-)" := Nor2  (at level 38, left associativity)  : Signal_scope.
Infix "!&" := nandb  (at level 40, left associativity)  : bool_scope.

(* simulation tools. *)

Local Open Scope string_scope.

(* convert an environment of type string->bool to string->string. *)
Definition benv2senv (env:string->bool) : string->string :=
   fun (s:string) => b2d (env s).

(* RTL-to-netlist *)

Fixpoint signal2str (s:Signal) {struct s} : string :=
 let s2s s := signal2str s in
 match s with
   | Bit0 => "0"
   | Bit1 => "1"
   | Not1 r => "~（" ++ (s2s r) ++ ")"
   | And2  r1 r2 => "("++(s2s r1) ++ "&&" ++ (s2s r2)++")"
   | Or2   r1 r2 => "("++(s2s r1) ++ "||" ++ (s2s r2)++")"
   | Xor2  r1 r2 => "("++(s2s r1) ++ "(+)" ++ (s2s r2)++")"
   | Eq2   r1 r2 => "~（" ++ ((s2s r1) ++ "^" ++ (s2s r2))++")"
   | Nand2 r1 r2 => "("++(s2s r1) ++ "!&" ++ (s2s r2)++")"
   | Nor2  r1 r2 => "~(" ++((s2s r1) ++ "||" ++ (s2s r2))++")"
   | Bitv v => v
   | Letb v e1 e2 => 
       let v1 := s2s e1 in
       let env1 x := if eqb x v then v1 else x in
          s2s e2 
 end.

Definition signal2_to_str (sc:Signal2) : string :=
  let (sum,cout) := sc in
   "(" ++ (signal2str sum) ++ "," 
   ++ (signal2str cout) ++ ")".

Definition mk_net1 : Signal -> string  := signal2str.
Definition mk_net2 : Signal2 -> string := signal2_to_str.

(* Simulation tool *)

(* type of two inputs - two outputs function. *)
Definition tp_22 := Signal->Signal->Signal2.
(* type of two inputs and three outputs. *)
Definition tp_32 := Signal->Signal->Signal->Signal2.

Definition simulate22 (f:tp_22) (a b: bool) : bool * bool :=
   let (x,y) := f (b2s a) (b2s b) in
      pair (s2b x) (s2b y).  

Definition simulate32 (f:tp_32) (a b c: bool) : bool * bool :=
   let (x,y) := f (b2s a) (b2s b) (b2s c) in
      pair (s2b x) (s2b y).  


(* generate verilog code. *)
Fixpoint gv (s:Signal) : string :=
 match s with
   | Bit0        => "1'b0"
   | Bit1        => "1'b1"
   | Bitv v      => v
   | Not1 r      => "~ (" ++ (gv r) ++ ")"
   | And2  r1 r2 => "(" ++ (gv r1) ++ ") & ("  ++ (gv r2) ++ ")"
   | Or2   r1 r2 => "(" ++ (gv r1) ++ ") | ("  ++ (gv r2) ++ ")"
   | Xor2  r1 r2 => "(" ++ (gv r1) ++ ") ^ ("  ++ (gv r2) ++ ")"
   | Eq2   r1 r2 => "(" ++ (gv r1) ++ ") == (" ++ (gv r2) ++ ")"
   | Nand2 r1 r2 => "(" ++ (gv r1) ++ ") ~& (" ++ (gv r2) ++ ")"
   | Nor2  r1 r2 => "(" ++ (gv r1) ++ ") ~| (" ++ (gv r2) ++ ")"
   | Letb v r1 r2 => "
      assign " ++ v ++ " = " ++ (gv r1) ++ ";
   " ++ (gv r2) ++ ";"
 end
.

Definition gv2 (sc : Signal2) : string :=
  let (sum,cout) := sc in
"
    assign sum = " ++ (gv sum) ++ ";
    assign cout = " ++ (gv cout) ++ ";
".


Fixpoint gv_pair (s2:Signal_Pair) : string :=
  match s2 with
   | Spair r1 r2   => "" (* gv2 (r1,r2) *)
   | Letb2 v r1 r2 => 
"
   assign " ++ v ++ " = " ++ (gv r1) ++ ";" ++ (gv_pair r2) 
 end
.

(* delay estimation. *)

(* calculate gate delay. *)
Fixpoint gdelay (s:Signal) : nat :=
 match s with
   | Bit0 => 0
   | Bit1 => 0
   | Bitv v      => 0
   | Not1 r => 1 + (gdelay r)
   | And2  r1 r2 => 2 + (max (gdelay r1) (gdelay r2))
   | Or2   r1 r2 => 2 + (max (gdelay r1) (gdelay r2))
   | Xor2  r1 r2 => 3 + (max (gdelay r1) (gdelay r2))
   | Eq2   r1 r2 => 3 + (max (gdelay r1) (gdelay r2))
   | Nand2 r1 r2 => 1 + (max (gdelay r1) (gdelay r2))
   | Nor2  r1 r2 => 1 + (max (gdelay r1) (gdelay r2))
   | Letb v r1 r2 => (gdelay r1) + (gdelay r2)
 end.

Definition gdelay2 (sc : Signal2) : nat :=
  let (sum,cout) := sc in
   max (gdelay sum) (gdelay cout).

(* This is not correct aera estimation since duplicated gates counted more than one times. *)
Fixpoint garea (s:Signal) : nat :=
 match s with
   | Bit0 => 0
   | Bit1 => 0
   | Bitv v      => 0
   | Not1 r => 1 + (garea r)
   | And2  r1 r2 => 4  + (garea r1) + (garea r2)
   | Or2   r1 r2 => 4  + (garea r1) + (garea r2)
   | Xor2  r1 r2 => 11 + (garea r1) + (garea r2)
   | Eq2   r1 r2 => 11 + (garea r1) + (garea r2)
   | Nand2 r1 r2 => 3  + (garea r1) + (garea r2)
   | Nor2  r1 r2 => 3  + (garea r1) + (garea r2)
   | Letb v r1 r2 => (garea r1) + (garea r2)
 end.

Definition garea2 (sc : Signal2) : nat :=
  let (sum,cout) := sc in
     (garea sum) + (garea cout).


(* Develepment of full adder. *)

Definition half_adder_s (a b : Signal) : Signal2 := 
 pair (a (+) b) (a && b).
 
Definition full_adder_s (a b cin : Signal) : Signal2 :=
  let (s1,c1) := half_adder_s a b in
  let (s2,c2) := half_adder_s s1 cin in
    pair s2 (c1 || c2).

(* RTL-to-netlist synthesis *)
  
Compute half_adder_s (Bitv "a") (Bitv "b").
Compute full_adder_s (Bitv "a") (Bitv "b") (Bitv "c").

Compute mk_net2 (half_adder_s (Bitv "a") (Bitv "b")).
Compute mk_net2 (full_adder_s (Bitv "a") (Bitv "b") (Bitv "c")).

(* Simulation *)

Compute (simulate22 half_adder_s true false).
Compute (simulate32 full_adder_s true false true).

(* verification by testbench and formal verification by exhaustive simulation. *)

(* boolean level full adder type. *)
Definition full_adder_tp := bool -> bool -> bool -> bool * bool.

(* generate boolean valued full adder by simulator. *)
Definition full_adder_b : full_adder_tp :=
  simulate32 full_adder_s.

(* direct simulation. *)
Compute full_adder_b true false true.
Compute full_adder_b false true true. (* false, true *)

(* testbench of full_adder. *)
Definition ck_full_adder_truth_tbl full_adder : Prop :=
  forall a b cin : bool,
  full_adder a b cin (* (sum, carry) *) =  
    match a,b,cin with
    | false,false,false  => (false, false)
    | false,false,true   => (true,  false)
    | false,true, false  => (true,  false)
    | false,true, true   => (false, true)
    | true, false,false  => (true,  false)
    | true, false,true   => (false, true)
    | true, true, false  => (false, true)
    | true, true, true   => (true,  true)
   end.


(* running exhaustive simulation -- formal verification. *)
Theorem full_adder_b_truth_tbl : 
 ck_full_adder_truth_tbl full_adder_b.
Proof.
  unfold ck_full_adder_truth_tbl.
  destruct a, b, cin; reflexivity.
Qed.
 
(* behavior level formal verification. *)

Definition ck_full_adder_ok
 (full_adder : full_adder_tp) : Prop :=
 forall a b cin : bool,
   let (sum,cout) := full_adder a b cin in 
     a + b + cin = 2 * cout + sum.  

Theorem full_adder_b_high_level_verification : 
 ck_full_adder_ok full_adder_b.
Proof.
  unfold ck_full_adder_ok.
  destruct a, b, cin; reflexivity.
Qed.


(* design and verification of an optimized full adder. *)
Definition full_adder_nand_s (a b cin : Signal) : Signal_Pair := 
 let n1 := Bitv "n1" in 
 let n21 := Bitv "n21" in let n22 := Bitv "n22" in
 let n3 := Bitv "n3" in
 let n4 := Bitv "n4" in
 let n51 := Bitv "n51" in let n52 := Bitv "n52" in
 let sum := Bitv "sum" in let cout := Bitv "cout" in
 Letb2 "n1"  (a !& b)
 (Letb2 "n21" (a !& n1) (Letb2 "n22" (b !& n1)
 (Letb2 "n3"  (n21 !& n22)
 (Letb2 "n4"  (n3 !& cin)
 (Letb2 "n51" (n3 !& n4) (Letb2 "n52" (n4 !& cin)
 (Letb2 "sum" (n51 !& n52)
 (Letb2 "cout" (n4 !& n1)
   (Spair sum cout))))))))).

(* to do
Theorem full_adder_nand_high_level_verification : 
 ck_full_adder_ok (simulate32 full_adder_nand_s).
Proof.
  unfold ck_full_adder_ok.
  destruct a, b, cin; reflexivity.
Qed.
*)

(* verilog code generation. *)
Definition x := Bitv "a".
Definition y := Bitv "b".
Definition z := Bitv "c".
Compute gv2 (full_adder_s      x y z).

(* delay calculation *)
Compute gdelay2 (full_adder_s x y z).

(* area calculation *)
Compute garea2 (full_adder_s x y z).


Require Import Strings.String.
Require Import Strings.Ascii.
Require Import Nat.


Open Scope string_scope.

Definition divmod (x y : nat) : nat * nat := (x / y, x mod y).
(*
Fixpoint nat_to_string (n : nat) : string :=
  match n with
  | 0 => "0"
  | 1 => "1"
  | 2 => "2"
  | 3 => "3"
  | 4 => "4"
  | 5 => "5"
  | 6 => "6"
  | 7 => "7"
  | 8 => "8"
  | 9 => "9"
  | _ =>
      let (q, r) := divmod n 10 in
      append (nat_to_string q) (nat_to_string r)
  end.
*)
(*
Fixpoint nat_to_string_aux (n : nat) (acc : string) : string :=
  match n with
  | 0 => if (string_dec acc "") then "0" else acc
  | 1 => String (ascii_of_nat (nat_of_ascii "1"%char)) acc
  | 2 => String (ascii_of_nat (nat_of_ascii "2"%char)) acc
  | 3 => String (ascii_of_nat (nat_of_ascii "3"%char)) acc
  | 4 => String (ascii_of_nat (nat_of_ascii "4"%char)) acc
  | 5 => String (ascii_of_nat (nat_of_ascii "5"%char)) acc
  | 6 => String (ascii_of_nat (nat_of_ascii "6"%char)) acc
  | 7 => String (ascii_of_nat (nat_of_ascii "7"%char)) acc
  | 8 => String (ascii_of_nat (nat_of_ascii "8"%char)) acc
  | 9 => String (ascii_of_nat (nat_of_ascii "9"%char)) acc
  | _ =>
      let (q, r) := divmod n 10 in
      nat_to_string_aux q (nat_to_string_aux r acc)
  end.
*)

(*
Require Import List.
Import ListNotations.
Fixpoint nat_to_string (n : nat) : string :=
  match n with
  | O => "0"
  | S n' => (nat_to_string n') ++ 
      (Ascii.ascii_of_nat (48 + Nat.modulo n 10)) :: nil
  end.
*)
(*
Definition digit_char (n : nat) : ascii :=
  match n with
  | 0 => "0"
  | 1 => "1"
  | 2 => "2"
  | 3 => "3"
  | 4 => "4"
  | 5 => "5"
  | 6 => "6"
  | 7 => "7"
  | 8 => "8"
  | 9 => "9"
  | _ => "0"
  end%char.

Fixpoint num_string (num : list nat) : string :=
  match num with
  | nil => ""
  | cons n l => String (digit_char n) (num_string l)
  end.

Fixpoint digits (input: nat) (output :list nat) {struct input} : list nat :=
  if (input =? 0)%nat
  then output
  else digits (input / 10) ((input mod 10)::output).
*)

Require Import Strings.String.
Require Import List.
Require Import Ascii String.
Require Import Nat.
Require Import Logic.FunctionalExtensionality.

Import ListNotations.
Open Scope string_scope.
Open Scope char_scope.

Definition natToDigit (n : nat) : ascii :=
  match n with
    | 1 => "1"
    | 2 => "2"
    | 3 => "3"
    | 4 => "4"
    | 5 => "5"
    | 6 => "6"
    | 7 => "7"
    | 8 => "8"
    | 9 => "9"
    | _ => "0"
  end.

Fixpoint writeNatAux (time n : nat) (acc : string) : string :=
  let acc' := String (natToDigit (n mod 10)) acc in
  match time with
    | 0 => acc'
    | S time' =>
      match n / 10 with
        | 0 => acc'
        | n' => writeNatAux time' n' acc'
      end
  end.

Definition writeNat (n : nat) : string :=
  writeNatAux n n "".


(* create a fresh variable. *)
Definition mk_fresh (v:string) (cnt:nat) :=
   v ++ (writeNat cnt).

(* direct signal *)
Inductive tpImmed :=
  LowV | HighV | SigVar : string -> tpImmed.

Inductive tpGateNo :=
   NotGate | And2Gate | Or2Gate 
  | Xor2Gate | Eq2Gate | Nor2Gate | Nand2Gate.

(* type of net list is a 4 element tuple: v := (op v1 v2) *)
Definition tpGateAssign2 := 
  (string * (tpGateNo * tpImmed * tpImmed))%type.

Definition tpGateAssign1 := 
  (string * (tpGateNo * tpImmed))%type.

(* type of immediate assignment is a pair v := i. *)
Definition tpImmedAssign :=
  (string * tpImmed)%type.

(* type of singgle element assignment: v := x *)
Inductive tpNetEle :=
  ImmedAss : tpImmedAssign -> tpNetEle
| GateAss1 : tpGateAssign1 -> tpNetEle
| GateAss2 : tpGateAssign2 -> tpNetEle.

Definition tpNetlist := list tpNetEle.

Open Scope string_scope.

(* an auxiliary function to generate netlist. *)
Fixpoint mkn (s:Signal) (cnt:nat) (nets:tpNetlist)
 : nat * tpNetlist :=
 let mkv (str:string) cnt := mk_fresh str cnt in

 let mkass2 r1 r2 gate_str gate_no :=
   let v1 := mkv (gate_str++"L") cnt in
   let v2 := SigVar (mkv (gate_str++"x") (cnt+1)) in
   let v3 := SigVar (mkv (gate_str++"y") (cnt+2)) in
   let ass := GateAss2 (v1,(gate_no, v2,v3)) in
   let '(cnt1, nets1) := mkn r1 (cnt+3) (ass::nets) in
      mkn r2 cnt1 nets1 
 in
 match s with
   | Bit0   => (cnt+1, (ImmedAss ((mkv "I" cnt), LowV))::nets)
   | Bit1   => (cnt+1, (ImmedAss ((mkv "I" cnt), HighV))::nets)
   | Bitv v => (cnt+1, (ImmedAss ((mkv "I" cnt), SigVar v))::nets)

   | Not1 r =>
       let v1 := mkv "N" cnt in
       let v2 := mkv "N" (cnt+1) in
       let ass := GateAss1 (v1,(NotGate, SigVar v2)) in
          mkn r (cnt+2) (ass::nets)   

   | And2  r1 r2 => mkass2 r1 r2 "And2"  And2Gate 
   | Or2   r1 r2 => mkass2 r1 r2 "Or2"   Or2Gate 
   | Xor2  r1 r2 => mkass2 r1 r2 "Xor2"  Xor2Gate 
   | Eq2   r1 r2 => mkass2 r1 r2 "Eq2"   Eq2Gate
   | Nand2 r1 r2 => mkass2 r1 r2 "Nand2" Nand2Gate
   | Nor2  r1 r2 => mkass2 r1 r2 "Nor2"  Nor2Gate
   | Letb v r1 r2 => 
       let '(cnt1, nets1) := (mkn r1 cnt nets) in
          mkn r2 cnt1 nets1          
 end. (* connection bug will be fixed later *)

Compute (mkn (snd 
  (half_adder_s (Bitv "x") (Bitv "y") )) 0 []).


Compute 
  (half_adder_s (Bitv "x") (Bitv "y") ).


Compute (mkn (snd 
  (full_adder_s (Bitv "x") (Bitv "y") (Bitv "z"))) 0 []).
(* 
Definition mk_netlist2 (sc : Signal2) : nat :=
  let (sum,cout) := sc in
     (mk_netlist sum) + (mk_netlist cout). *)


Require Import require.

Definition tpPairList_s := list (Signal * Signal).
Definition tpPairList_b := list (bool * bool).
Implicit Type ab : tpPairList_s.
Implicit Type c  : Signal.

Definition tpSumCarry_s := ((list Signal) * Signal)%type.
Definition tpSumCarry_b := ((list bool) * bool)%type.

(* export ripple carry adder definition. *)
Fixpoint rc_adder_s ab c {struct ab} : tpSumCarry_s :=
  match ab with
    | (an,bn) :: ab' =>
      let (sum,carry) := rc_adder_s ab' c in
	let (sn,cn) := full_adder_s an bn carry in
	  ((sn::sum),cn)
    | nil => (nil,c)
  end.

(* type of ripple carry adder at the signal level. *)
Definition tpRcAdder_s := 
  tpPairList_s -> Signal -> tpSumCarry_s.
(* type of ripple carry adder at the boolean level. *)
Definition tpRcAdder_b :=
  tpPairList_b -> bool -> tpSumCarry_b.
   
(* conversion from signal pair list to boolean pair list. *)
Definition spairs2bpairs (pl:tpPairList_s) : tpPairList_b :=
  List.map (fun (xy:Signal*Signal) => 
     (s2b (fst xy), s2b (snd xy))) pl.
 
(* conversion from boolean pair list to signal pair list. *)
Definition bpairs2spairs (pl:tpPairList_b) : tpPairList_s :=
  List.map (fun (xy:bool*bool) => 
    (b2s (fst xy), b2s (snd xy))) pl.

Definition tpList_s := list Signal.
Definition tpList_b := list bool.

(* convert signal list to boolean list. *)
Definition slist2blist (slist:tpList_s) : tpList_b :=
  List.map s2b slist.

(* conversion from signal level adder to boolean level adder. *)
Definition adder_s2b (f:tpRcAdder_s) : tpRcAdder_b :=
  fun (ab:tpPairList_b) (c:bool) =>
    let sc := f (bpairs2spairs ab) (b2s c) in
    let sums := fst sc in
    let carry := snd sc in
       (slist2blist sums, s2b carry).

Definition rc_adder_b : tpRcAdder_b := adder_s2b rc_adder_s.

Lemma let_split : forall {A B C:Set} (xy:A*B) (e:C), 
  let (x,y) := xy in e = 
  let x := fst xy in
  let y := snd xy in e.
intros. simpl. destruct xy. reflexivity.
Qed.


Lemma let_match : forall {A B C:Set} (xy:A*B) (e:C), 
  let (x,y) := xy in e = 
  match xy with (x,y) => e end.
intros. simpl. destruct xy.  reflexivity.
Qed.


Lemma let_lam : forall {A B C:Set} (xy:A*B) (e:C), 
  let (x,y) := xy in e = 
  (fun x y => e) (fst xy) (snd xy) .
intros. simpl. destruct xy.  reflexivity.
Qed.


Lemma rc_adder_carry_red : 
  forall (a b:bool) (xy:tpPairList_b) (c:bool),
  snd (rc_adder_b ((a,b)::xy) c) = 
  ci (a + b + (snd (rc_adder_b xy c))).
Proof. intros. 
letPairSimp. generalize (rc_adder_s (bpairs2spairs xy) (b2s c)).
intro. destruct t. simpl. unfold s2b. simpl.

 destruct a,b; trivial. 
+ simpl. generalize (fun _ : string => true).
intro b. generalize (signal2bool s b). intro b0.
destruct b0;
 reflexivity.
+ simpl. generalize (fun _ : string => true).
intro b. generalize (signal2bool s b). intro b0.
destruct b0;
 reflexivity.
+ simpl. generalize (fun _ : string => true).
intro b. generalize (signal2bool s b). intro b0.
destruct b0;
 reflexivity.
Qed.


Lemma rc_adder_carry_red_s : 
  forall (a b:Signal) (xy:tpPairList_s) (c:Signal),
  s2b (snd (rc_adder_s ((a,b)::xy) c)) = 
  ci ((s2b a) + (s2b b) + (s2b (snd (rc_adder_s xy c)))).
Proof. intros.



Lemma rc_adder_carry_red : forall a b xy c,
  s2b (snd (rc_adder ((a,b)::xy) c)) = 
  ci ((s2b a) + (s2b b) + (s2b (snd (rc_adder xy c)))).
Proof. funRed. Qed.